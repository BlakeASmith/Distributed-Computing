%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Distributied Computing Summer 2020}
\date{May 30, 2020}
\release{0.0.1}
\author{Blake Smith}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Google Article on Distributed Systems}
\label{\detokenize{google_article:google-article-on-distributed-systems}}\label{\detokenize{google_article::doc}}

\section{Leslie Lamport Quote}
\label{\detokenize{google_article:leslie-lamport-quote}}\begin{quote}\begin{description}
\item[{A distributed system is}] \leavevmode
one in which the failure of a computer that
you didn’t even know existed causes your computer to be unuseable

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{No single point of failiure}] \leavevmode\begin{itemize}
\item {} 
\sphinxhyphen{}\textgreater{} many points of failure \sphinxhyphen{}\textgreater{} partial failiure

\end{itemize}

\end{description}

\item {} 
more scalable, you can throw more hardware nodes at the problem

\item {} 
shared computation between nodes can lead us to lots of problems

\end{itemize}


\section{Tutorial}
\label{\detokenize{google_article:tutorial}}\begin{quote}\begin{description}
\item[{A distributed system is}] \leavevmode
an application that executes a collection
of protocols to co\sphinxhyphen{}ordinate the actions
of multuple processes on a network, such that
all components coperate together to perform a
single or small set of related tasks.

\end{description}\end{quote}

Fault tolerance is really important:
\begin{quote}
\begin{quote}\begin{description}
\item[{Fault Tolerant}] \leavevmode
the system can recover from failiures without
fucking up something else

\item[{Highly Available}] \leavevmode
continues to provide services even when some
components have failed

\item[{Recoverable}] \leavevmode
components can be added back into the system after
they have been repaired, or the failiure has been otherwise
resolved

\item[{Consistent}] \leavevmode
the system acts like a non\sphinxhyphen{}distributed system by co\sphinxhyphen{}ordinating
the actions of it’s components while managing failures and concurrency

\item[{Scalable}] \leavevmode
continues to operate effectivley when the system is scaled in
some aspect such as the number of nodes in the network or the overall
load on the system. These things add complexity and increase the frequency
of failures. This should not have a significant efffect on the system
as a whole

\item[{predictable performance}] \leavevmode
does the system behave predictably when
more nodes are added? when more data is added?

\end{description}\end{quote}
\end{quote}

Security is also really important

Distributed systems must be designed with the \sphinxstylestrong{expectation} of failiure
\begin{itemize}
\item {} 
If there is a 1/10,000 chance of a failiure, that means it happends \sphinxstylestrong{all the time}

\item {} 
Distributed systems must be designed with the though that failiure happens
all the time, because it kind of does

\item {} 
\textendash{}\textgreater{} \sphinxstylestrong{multiplier on the value of simplicity}

\end{itemize}


\subsection{Bugs}
\label{\detokenize{google_article:bugs}}
Two major categories of bugs in distributed systems:
\begin{quote}
\begin{quote}\begin{description}
\item[{Heisenbug}] \leavevmode
A bug that seems to change or disappear entirley
when it is observed/researched (Heisenburg Uncertainty Principle)

\item[{Bohrbug}] \leavevmode
opposite of a Heisenbug. It manifests itself under a well defined
set of conditions (consistently)

\end{description}\end{quote}
\end{quote}


\subsection{Failiures and Fallacies}
\label{\detokenize{google_article:failiures-and-fallacies}}
many types of failiure:
\begin{quote}
\begin{quote}\begin{description}
\item[{haulting failure}] \leavevmode
the thing just stops
\begin{itemize}
\item {} 
can’t tell if it’s slow or dead

\item {} 
timeout goes off, but that doesnt mean it’s shut down

\end{itemize}

\item[{Fail stop}] \leavevmode
like a haulting failure but with some notification
to other components

\item[{Omission Failiures}] \leavevmode
a message didn’t make it (primarily due to buffer overflow
at some node in the network)

\item[{Network Failure}] \leavevmode
the network goes

\item[{Network Partition}] \leavevmode
there is a split between two or more disjoint
clusters in the network. the network is operational within these
sub\sphinxhyphen{}networks, but they cannot communicate accross their bounds

\item[{Timing}] \leavevmode
some temporal property of the system is violated
no centralized clock \textendash{}\textgreater{} dificulty with timing

\item[{Bysantine}] \leavevmode
data corruption, malicious programs, a whole list here

\end{description}\end{quote}
\end{quote}


\subsubsection{Some wrong assumptions can lead to bysantine behaviour}
\label{\detokenize{google_article:some-wrong-assumptions-can-lead-to-bysantine-behaviour}}\begin{itemize}
\item {} 
Reliable network

\item {} 
zero latency

\item {} 
infinite bandwidth

\item {} 
secure network

\item {} \begin{description}
\item[{topologies don’t change}] \leavevmode\begin{itemize}
\item {} 
truth is that nodes come and go

\end{itemize}

\end{description}

\item {} 
1 administrator

\item {} 
Transport cost (copying, buffering)

\item {} 
Homogenous network (nodes/links are the same accross the system)

\end{itemize}


\subsection{How?}
\label{\detokenize{google_article:how}}\begin{quote}\begin{description}
\item[{client\sphinxhyphen{}server}] \leavevmode
more realistically, service\sphinxhyphen{}client where the service is
made up of multiple running nodes

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{binding}] \leavevmode\begin{itemize}
\item {} 
A process that wants to use a service gets associated to
a specific server providing the service, think \sphinxcode{\sphinxupquote{socket.bind(addr, port)()}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{replication}] \leavevmode\begin{itemize}
\item {} 
multiple copies of data across the system to increase availability
(if some node goes down) and allow local access in multiple locations

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{caching}] \leavevmode\begin{itemize}
\item {} 
store a local copy of the data for quick access if it is requested again

\item {} 
cach data can go stale and needs to be updated periodically. If the cached
data is refreshed by/ syncronized to the service data then this is actually
replication

\end{itemize}

\end{description}

\end{itemize}

TCP, UDP, \sphinxstylestrong{RPC}
\begin{quote}\begin{description}
\item[{\sphinxstylestrong{RPC}}] \leavevmode
Remote Procedure Call, It’s like a distributed function call

\end{description}\end{quote}


\subsection{Remote Procedure Calls}
\label{\detokenize{google_article:remote-procedure-calls}}
emulates a local procedure call over a network. Arguments are sent to the
server through a packet (or multiple). The server executes the requested service
and sends a response packet back to the client. The client process can then
continue


\subsection{Design Principles}
\label{\detokenize{google_article:design-principles}}\begin{itemize}
\item {} 
idenentify failure senarios explicitly and ensure that the code is covered for
the most likley ones

\item {} 
prepare of unresponsive senders/receivers in both the client and server code

\item {} 
minimize network traffic, every request/response increases the probability of failure

\item {} 
don’t assume that data arriving from one process to another is the same data that was
sent. Use validity checks like checksums to ensure the data has not changed

\item {} 
avoid acks, they’re expensive

\item {} 
retransmission is costly. Adjust the delay for optimal transmission

\end{itemize}

When a process  A stores information that cannot be reconstructed it can pose a problem to
the distributed system. Other processes must go A for that data, A becomes a single point
of failiure. So A’s data must be replicated somewhere else as a backup, but then we have
problems with managing the changes of that data between the replicated sources. This
presents a trade\sphinxhyphen{}off between accessability of the data (the ability to procure it at all)
and acccuracy of the data.
\begin{quote}\begin{description}
\item[{DONE}] \leavevmode
review forum posts with answers :done:8/05/20 06:18PM

\item[{link}] \leavevmode
\sphinxurl{https://coursespaces.uvic.ca/mod/hsuforum/discuss.php?d=87144\#p145524}

\item[{DONE}] \leavevmode
Answer some more question from the article :done:9/05/20 06:18PM

\item[{link}] \leavevmode
\sphinxurl{http://www.hpcs.cs.tsukuba.ac.jp/~tatebe/lecture/h23/dsys/dsd-tutorial.html}

\end{description}\end{quote}


\section{Exercises}
\label{\detokenize{google_article:exercises}}\begin{quote}\begin{description}
\item[{Q1}] \leavevmode
Have you ever encountered a Heisenbug? How did you isolate and fix it

\end{description}\end{quote}


\bigskip\hrule\bigskip

\begin{quote}

I’m currently working on a text\sphinxhyphen{}processing library for recognizing patterns within
plain text documents and converting them into python objects. Similarly to what
we can already do with JSON but for any format. It uses a string template to define a
‘text object’ which can then be recognized in text and it’s various attributes extracted
from the text. This allows any arbitrary data to be read as if it were structured data.

Repeated function composition is used to alter the matching behaviour as the template
string is read. The ultimate result is a function which takes a string as input and
returns an object with attributes matching the placholders in the template string.
There is also recursion involved in this process so it can become somewhat difficult
to reason about.

I ran into a problem in which the same string template would match a peice of text
most of the time, except when it didn’t. This only happened about 1/10 times and it
was unclear how to repoduce the bug.

My first approach was to log the current remaining text along with the next sub\sphinxhyphen{}pattern
being considered. I ran a script to attemt the match a few thousand times and used grep
to get all the lines at which the match failed.

I found that in the faliure cases the pattern being considered did not occur until
much farther along in the template, but was for some reason being attempted early.

I isolated the bug to one specific function which was responsible for handling the
\sphinxtitleref{search} modifer which allows a placholder to be searched for in the text as apposed
to directly matching the beginning. However there was no indication of what was
going wrong, and that routine worked in every case I tried to put it through

Ultimiatley I found that the bug had nothing to do with the routine itself but with
how the arguments were supplied. Within the routine a wrapper function was defined to
add the searching functionallity. The current regex pattern being considered was an
argument to the enclosing function, and was available to the wrapper function through
the enclosing scope (closure). It turns out that python uses late\sphinxhyphen{}binding, meaning that
the wrapper function was accessing the value as it was when the wrapper function
was \sphinxstylestrong{invoked}, where as it needed to access the value as it was at the time when the
wrapper function was \sphinxstylestrong{defined}. Thus the problem came from the value of that pattern
variable changing between the time that the function was defined and the time that the
function was invoked

Placeholders can be marked as \sphinxtitleref{optional}. If this is the case then the template string
is evaluated both with and without the placeholder (concurrently).
The template string in question
that was having the inconsistant behavior had several of these optional placeholders.
It turned out that in most cases, the late\sphinxhyphen{}binding did not cause a problem because in
the order in which these branches happened to return that specific wrapper
function was the last one to be composed with the output function,
thus the value of the pattern variable did not change. However some of the time the
branches would return in a different order, resulting in the bug manifesting

The solution was to add \sphinxtitleref{pattern=pattern} in the arguments to the wrapper function.
\end{quote}
\begin{quote}\begin{description}
\item[{Q2}] \leavevmode
What is the difference between caching and data replication

\end{description}\end{quote}


\bigskip\hrule\bigskip

\begin{quote}

cached data has an expiration date and is not syncronized to the main dataset.
typically cached data will only be updated when it is requested. In contrast
data replication aims to keep the replicated data in the same state as the
data which is being replicated. If cached data is continually updated to match
the service data, then that is data replication and not caching. Caching and data
replication also differ in purpose. Caching is something you do to improve speed when
the same data is requested multiple times (you trade accuracy of the data for speed).
In contrast data replication aims to improve accessabiltiy/availability of the data
(in the case that another node fails) and can create overhead (keeping the data in
sync). Caching has the effect of reducing the number of requests sent over the network
as nodes will use the local cache in place of making a request to another node if
possible. Data replication may have effect of increasing the number of requests in the
network as additional packets must be transmitted to manage the syncronization
of the data.
\end{quote}


\chapter{Noes from AWS Beyond Eleven Nines Talk}
\label{\detokenize{aws_beyondelevennines_talk:noes-from-aws-beyond-eleven-nines-talk}}\label{\detokenize{aws_beyondelevennines_talk::doc}}\begin{quote}\begin{description}
\item[{see full talk here}] \leavevmode
\sphinxurl{https://www.youtube.com/watch?time\_continue=582\&v=DzRyrvUF-C0\&feature=emb\_logo}

\end{description}\end{quote}
\begin{itemize}
\item {} 
trillions of objects, needed to scale over the years

\end{itemize}


\section{Lessons from security}
\label{\detokenize{aws_beyondelevennines_talk:lessons-from-security}}\begin{quote}\begin{description}
\item[{Threat Model}] \leavevmode
Get really specific about what a threat is

\item[{Q}] \leavevmode
Who is the attacker?, what can they do?, what are they trying to do to us?

\item[{A}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Pick a specific risk (eg. account hacking)

\item {} 
What could they do (eg. password guessing)

\item {} 
What are they tring to do (eg. steal accounts to send spam)

\end{enumerate}

\item[{next}] \leavevmode
move to pros, answer the questions in detail

\end{description}\end{quote}
\begin{description}
\item[{Implement Mechanisms}] \leavevmode\begin{itemize}
\item {} 
Ongoing

\item {} 
Technical and organizational approaches

\end{itemize}

\end{description}

Attacker could be failiure, decay, does not need to be someone


\section{Common Threats}
\label{\detokenize{aws_beyondelevennines_talk:common-threats}}\begin{quote}\begin{description}
\item[{problem}] \leavevmode
Facility Failiure
* any single facility can fail at any time

\item[{solution}] \leavevmode
availability zones, hazard analysis
\sphinxhyphen{}\textgreater{} Buildings that won’t fail together

\item[{quote}] \leavevmode
writing is natures way of showing you how sloppy your thinking is

\item[{problem}] \leavevmode
Hardware Failiure

\end{description}\end{quote}

worry about the worst exposed componants, not the averages
\begin{quote}\begin{description}
\item[{quote}] \leavevmode
you are only as good as you are able to measure yourself

\item[{problem}] \leavevmode
Data corruption

\end{description}\end{quote}

myths:
* TCP checksums got be covered
* CPU won’t lie to me
* Data coruption is a hardware problem
* Corruption is always a single bit flip
\begin{quote}\begin{description}
\item[{problem}] \leavevmode
Bugs

\end{description}\end{quote}
\begin{itemize}
\item {} 
code level bugs

\item {} 
design level bugs

\end{itemize}

zonal delpoys
\textasciigrave{}


\section{Best Practices}
\label{\detokenize{aws_beyondelevennines_talk:best-practices}}

\section{BYO Threat Models}
\label{\detokenize{aws_beyondelevennines_talk:byo-threat-models}}

\chapter{Clock Exercise}
\label{\detokenize{clock_exercise/clock_exercise:clock-exercise}}\label{\detokenize{clock_exercise/clock_exercise::doc}}\begin{quote}\begin{description}
\item[{Q}] \leavevmode
How did you calculate your clients average clock drift rate?

\end{description}\end{quote}


\bigskip\hrule\bigskip


After each successful request to the NTP server I divided the
calculated clock offset by \(10 + 10*numfails\) where
\sphinxstylestrong{numfails} is the number of failed attempts since the last
successful attempt. Since a request to the server is made every 10
seconds this gives a good approximation for the drift per second (in microseconds).
I kept an array of these values and calculated the average at each iteration.
The final average was \(12.032miliseconds\)


\section{Picking the Timeout}
\label{\detokenize{clock_exercise/clock_exercise:picking-the-timeout}}\begin{quote}\begin{description}
\item[{Question}] \leavevmode
what timeout did you pick to detect a failed interaction? What
happens if the server’s response packet arrives after that timeout

\end{description}\end{quote}

I picked \sphinxstylestrong{10 seconds} as the timeout. The resulting packet loss rate was \(4%\).
When a timeout occurred the failure was counted and no other stats were calculated

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{t3} \PYG{o}{=} \PYG{n}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{data}\PYG{p}{,} \PYG{n}{address} \PYG{o}{=} \PYG{n}{client}\PYG{o}{.}\PYG{n}{recvfrom}\PYG{p}{(} \PYG{l+m+mi}{1024} \PYG{p}{)}
                \PYG{n}{t0} \PYG{o}{=} \PYG{n}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{succs} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{ex}\PYG{p}{:}
                \PYG{n}{losses} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
                \PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{timeout: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{losses}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{continue}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{n}{stat} \PYG{o}{=} \PYG{p}{\PYGZob{}}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{off}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{rtt}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smoothed\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{smoff}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smoothed\PYGZus{}RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{smrtt}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{drop\PYGZus{}rate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{losses}\PYG{o}{/}\PYG{p}{(}\PYG{n}{succs}\PYG{o}{+}\PYG{n}{losses}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}system\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{now}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adjusted\PYGZus{}system\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{adjusted}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{drift}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{drifts}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{drifts}\PYG{p}{)}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{rtts}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rtts}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{n}{stat}\PYG{p}{)}
        \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Graphing the Clock Drift}
\label{\detokenize{clock_exercise/clock_exercise:graphing-the-clock-drift}}
I created this histogram of the clock drift per second (in miliseconds) for each
successful interaction with the server. Note that there were 3200 interactions logged



As you can see most of the time the drift was positive, meaning that my machine’s
clock was running faster than the NTP server’s. The histogram reflects a fairly normal distribution.



The scatter plot shows that the clock drift skews slightly to the right over time, but the width
(range of the values) stays mostly constant. Adding in the plot of the average drift (calculated at
each interaction) you can get a better picture of the overall trend. The average slowly increases over time
which means that the client machine is getting out of sync with the NTP server at a faster rate.


\section{Python Code for the NTP client}
\label{\detokenize{clock_exercise/clock_exercise:python-code-for-the-ntp-client}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{socket}
\PYG{k+kn}{import} \PYG{n+nn}{struct}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{NTP\PYGZus{}SERVER} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.uk.pool.ntp.org}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TIME1970} \PYG{o}{=} \PYG{l+m+mi}{2208988800}

\PYG{n}{logger} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rtt\PYGZus{}and\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{logger}\PYG{o}{.}\PYG{n}{setLevel}\PYG{p}{(}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{DEBUG}\PYG{p}{)}
\PYG{n}{handler} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{FileHandler}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rtt\PYGZus{}offset.log}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{handler}\PYG{o}{.}\PYG{n}{setLevel}\PYG{p}{(}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{DEBUG}\PYG{p}{)}
\PYG{n}{logger}\PYG{o}{.}\PYG{n}{addHandler}\PYG{p}{(}\PYG{n}{handler}\PYG{p}{)}


\PYG{n}{SOCKET\PYGZus{}TIMEOUT} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{NANOS} \PYG{o}{=} \PYG{l+m+mi}{1000000000}

\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{t}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{NANOS}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{diff}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{secs} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{nanos} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{nanos} \PYG{o}{=} \PYG{p}{(}\PYG{n}{NANOS}\PYG{p}{)}\PYG{o}{*}\PYG{n}{secs} \PYG{o}{+} \PYG{n}{nanos}

    \PYG{k}{return} \PYG{n}{nanos}

\PYG{k}{def} \PYG{n+nf}{addnanos}\PYG{p}{(}\PYG{n}{it}\PYG{p}{,} \PYG{n}{nanos}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newnanos}\PYG{p}{,} \PYG{n}{secs} \PYG{o}{=} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{nanos}\PYG{p}{,} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{newnanos} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{NANOS}\PYG{p}{:}
        \PYG{n}{secs} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1} 
        \PYG{n}{newnanos} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{NANOS}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{secs}\PYG{p}{,} \PYG{n}{newnanos}\PYG{p}{)}

\PYG{n}{stats}\PYG{p}{,} \PYG{n}{drifts}\PYG{p}{,} \PYG{n}{rtts} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{succs}\PYG{p}{,} \PYG{n}{losses}\PYG{p}{,} \PYG{n}{cur\PYGZus{}fails} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}x1b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{47} \PYG{o}{*} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{encode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{client} \PYG{o}{=} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{socket}\PYG{p}{(}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{AF\PYGZus{}INET}\PYG{p}{,} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{SOCK\PYGZus{}DGRAM}\PYG{p}{)}
    \PYG{n}{client}\PYG{o}{.}\PYG{n}{settimeout}\PYG{p}{(}\PYG{n}{SOCKET\PYGZus{}TIMEOUT}\PYG{p}{)}
    \PYG{n}{client}\PYG{o}{.}\PYG{n}{sendto}\PYG{p}{(} \PYG{n}{data}\PYG{p}{,}\PYG{p}{(} \PYG{n}{NTP\PYGZus{}SERVER}\PYG{p}{,} \PYG{l+m+mi}{123} \PYG{p}{)}\PYG{p}{)}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{t3} \PYG{o}{=} \PYG{n}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{data}\PYG{p}{,} \PYG{n}{address} \PYG{o}{=} \PYG{n}{client}\PYG{o}{.}\PYG{n}{recvfrom}\PYG{p}{(} \PYG{l+m+mi}{1024} \PYG{p}{)}
        \PYG{n}{t0} \PYG{o}{=} \PYG{n}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{succs} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{ex}\PYG{p}{:}
        \PYG{n}{losses} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{timeout: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{losses}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{continue}

    \PYG{n}{resp} \PYG{o}{=} \PYG{n}{struct}\PYG{o}{.}\PYG{n}{unpack}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!12I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{p}{)}

    \PYG{n}{reference} \PYG{o}{=} \PYG{p}{(}\PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{TIME1970}\PYG{p}{,} \PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{n}{NANOS}\PYG{p}{)}
    \PYG{n}{originate} \PYG{o}{=} \PYG{p}{(}\PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{TIME1970}\PYG{p}{,} \PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{n}{NANOS}\PYG{p}{)}
    \PYG{n}{receive}   \PYG{o}{=} \PYG{p}{(}\PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{TIME1970}\PYG{p}{,} \PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{n}{NANOS}\PYG{p}{)}
    \PYG{n}{transmit}  \PYG{o}{=} \PYG{p}{(}\PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{TIME1970}\PYG{p}{,} \PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{n}{NANOS}\PYG{p}{)}

    \PYG{n}{t1}\PYG{p}{,} \PYG{n}{t2} \PYG{o}{=} \PYG{n}{transmit}\PYG{p}{,} \PYG{n}{receive}

    \PYG{n}{off}\PYG{p}{,} \PYG{n}{rtt} \PYG{o}{=} \PYG{p}{(}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{t3}\PYG{p}{,}\PYG{n}{t2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{diff}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{,}\PYG{n}{t0}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{diff}\PYG{p}{(}\PYG{n}{t3}\PYG{p}{,} \PYG{n}{t0}\PYG{p}{)}
    \PYG{n}{drift} \PYG{o}{=} \PYG{n}{off}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{rtt}\PYG{o}{/}\PYG{n}{NANOS}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{losses}\PYG{o}{\PYGZhy{}}\PYG{n}{cur\PYGZus{}fails}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{drifts}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{drift}\PYG{p}{)}
    \PYG{n}{cur\PYGZus{}fails} \PYG{o}{=} \PYG{n}{losses}

    \PYG{n}{rtts}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{rtt}\PYG{p}{)}

    \PYG{n}{stats}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rtt}\PYG{p}{,} \PYG{n}{off}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{stats}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{:}
        \PYG{n}{stats} \PYG{o}{=} \PYG{n}{stats}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}

    \PYG{n}{smrtt}\PYG{p}{,} \PYG{n}{smoff} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{stats}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{st}\PYG{p}{:} \PYG{n}{st}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{now} \PYG{o}{=} \PYG{n}{calc\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{adjusted} \PYG{o}{=} \PYG{n}{addnanos}\PYG{p}{(}\PYG{n}{now}\PYG{p}{,} \PYG{n}{smoff}\PYG{p}{)}

    \PYG{n}{stat} \PYG{o}{=} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{off}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{rtt}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smoothed\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{smoff}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smoothed\PYGZus{}RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{smrtt}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{drop\PYGZus{}rate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{losses}\PYG{o}{/}\PYG{p}{(}\PYG{n}{succs}\PYG{o}{+}\PYG{n}{losses}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}system\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{now}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adjusted\PYGZus{}system\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{adjusted}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{drift}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{drifts}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{drifts}\PYG{p}{)}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{rtts}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rtts}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{n}{stat}\PYG{p}{)}

    \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}



\end{sphinxVerbatim}


\section{Python Code for Parsing the Log and Producing the Graphs}
\label{\detokenize{clock_exercise/clock_exercise:python-code-for-parsing-the-log-and-producing-the-graphs}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{import} \PYG{n+nn}{pandas}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{express} \PYG{k}{as} \PYG{n+nn}{px}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{graph\PYGZus{}objects} \PYG{k}{as} \PYG{n+nn}{go}
\PYG{k+kn}{from} \PYG{n+nn}{types} \PYG{k+kn}{import} \PYG{n}{SimpleNamespace}

\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rtt\PYGZus{}offset.log}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{log}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{re}\PYG{o}{.}\PYG{n}{findall}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{.*?\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{log}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{stats} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{]}

\PYG{n}{avg\PYGZus{}RTT} \PYG{o}{=} \PYG{n}{stats}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}RTT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{1000000000}
\PYG{n}{packet\PYGZus{}loss\PYGZus{}rate} \PYG{o}{=} \PYG{n}{stats}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{drop\PYGZus{}rate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{avg\PYGZus{}drift\PYGZus{}in\PYGZus{}milis} \PYG{o}{=} \PYG{n}{stats}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{1000000}


\PYG{k}{for} \PYG{n}{stat} \PYG{o+ow}{in} \PYG{n}{stats}\PYG{p}{:}
    \PYG{n}{stat}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{1000000}
    \PYG{n}{stat}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{1000000}

\PYG{n}{frame} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{stats}\PYG{p}{)}

\PYG{n}{fig} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{frame}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
        \PYG{n}{marginal} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{violin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Histogram of Clock Drift Per Second}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
        \PYG{n}{labels}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{drift\PYGZus{}in\PYGZus{}miliseconds\PYGZus{}per\PYGZus{}second}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{percent of records}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} 
        \PYG{n}{opacity}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,} 
        \PYG{n}{color\PYGZus{}discrete\PYGZus{}sequence}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indianred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{hover\PYGZus{}data}\PYG{o}{=}\PYG{n}{frame}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{update\PYGZus{}layout}\PYG{p}{(}\PYG{n}{xaxis\PYGZus{}title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Drift in miliseconds/sec}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{yaxis\PYGZus{}title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Count}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{write\PYGZus{}html}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fig1.html}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{frame}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current\PYGZus{}drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{add\PYGZus{}trace}\PYG{p}{(}\PYG{n}{go}\PYG{o}{.}\PYG{n}{Scattergl}\PYG{p}{(}
    \PYG{n}{x}\PYG{o}{=}\PYG{n}{frame}\PYG{o}{.}\PYG{n}{average\PYGZus{}drift}\PYG{p}{,} 
    \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{markers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average drift at each interaction}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
     \PYG{n}{marker}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}
        \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}
        \PYG{n}{color}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{}set color equal to a variable}
        \PYG{n}{colorscale}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Viridis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} one of plotly colorscales}
        \PYG{n}{line\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mi}{1}
    \PYG{p}{)}
\PYG{p}{)}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{update\PYGZus{}layout}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scatterplot of Clock Drift}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
        \PYG{n}{xaxis\PYGZus{}title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Drift in miliseconds/sec}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} 
        \PYG{n}{yaxis\PYGZus{}title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Count}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{write\PYGZus{}html}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fig2.html}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}



\end{sphinxVerbatim}


\chapter{Semantics of RPC}
\label{\detokenize{week2:semantics-of-rpc}}\label{\detokenize{week2::doc}}

\section{Upper Bound}
\label{\detokenize{week2:upper-bound}}\begin{quote}\begin{description}
\item[{upper bound on latency?}] \leavevmode
shared bandwidth, busy routers, async communication

\item[{Question}] \leavevmode
How long do you wait before timeout?

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{it’s difficult to determine if server is alive or dead}] \leavevmode\begin{itemize}
\item {} 
could be a bug in the router or something else unexpected

\item {} 
Independant failiure is a real struggle

\end{itemize}

\end{description}

\item {} 
we need to engineer the system to always be able to make forward progress

\end{itemize}


\section{Multi Core system vs Distributed System}
\label{\detokenize{week2:multi-core-system-vs-distributed-system}}
\#DONE: Multi X video 16/05/20 01:26PM

Multi core computers are not real distributed system
\begin{itemize}
\item {} 
not as much failiure potential as a DS

\item {} 
core failiure can happen, but is much less likley

\item {} \begin{description}
\item[{failiures of one core tend to lead to catestrophic failiures}] \leavevmode\begin{itemize}
\item {} 
so it’s hard not to notice the failiures

\end{itemize}

\end{description}

\end{itemize}


\section{LPC vs RPC semantics}
\label{\detokenize{week2:lpc-vs-rpc-semantics}}
\#DONE: LPC vs RPC video 16/05/20 01:35PM
\begin{quote}\begin{description}
\item[{LPC}] \leavevmode
it works or it doesn’t
\begin{itemize}
\item {} 
occurs exactly once

\end{itemize}

\item[{RPC}] \leavevmode
it might have worked? it might have not?
\begin{itemize}
\item {} \begin{description}
\item[{impossible to guarentee “exactly once” execution}] \leavevmode\begin{itemize}
\item {} 
server could go down

\item {} 
race conditions

\end{itemize}

\end{description}

\item {} 
“at most once” is the best we can do

\item {} 
lots of stuff in between that can go wrong

\item {} 
It’s hard to tell and can lead to some really bad side effects!

\end{itemize}

\end{description}\end{quote}


\section{Transperancy in DS}
\label{\detokenize{week2:transperancy-in-ds}}
\#DONE: Transperancy Video 16/05/20 01:39PM

The idea of RPC is nice since, if it acts like a LPC, it is
easy to use and reason about. However there is a trade off
between that ease of use (similarity to LPC) and Transperancy
(How much you get to know about that the DS is doing)

A total lack of transperancy means a seemingly easy to use function that
looks like an LPC. But if something is going wrong in the DS (network errors,
downed server, slow server, etc.) it will be harder to sus out

How much control do you give to the user of the RPC?
How do you name the RPC? What about binding?


\section{gRPC a open source RPC Library}
\label{\detokenize{week2:grpc-a-open-source-rpc-library}}
\#STARTED: gRPC prelab :start:16/05/20 01:48PM
\begin{quote}\begin{description}
\item[{Question}] \leavevmode
What do you find most intersing about this and why?

\end{description}\end{quote}


\bigskip\hrule\bigskip


definitly streaming messages
\#TODO:
\begin{quote}\begin{description}
\item[{Main Idea}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Specify methods with parameters and return types

\item {} 
Implement that interface on the server

\item {} 
Create a stub on the client side which provides
that interface

\end{enumerate}

\end{description}\end{quote}


\subsection{Data Representation}
\label{\detokenize{week2:data-representation}}
gRPC uses something called \sphinxstylestrong{Protocol Buffers}
\begin{quote}\begin{description}
\item[{Protocol Buffer}] \leavevmode
An open source mechanism for serializing structured data
(Google did it). It can also be used with other formats
such as JSON

\end{description}\end{quote}


\subsubsection{Proto Files}
\label{\detokenize{week2:proto-files}}
a \sphinxstylestrong{Proto File} specifies what the data will look like
(similar to a class/struct definition)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{message} \PYG{n}{Person} \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{name} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{int32} \PYG{n+nb}{id} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{n+nb}{bool} \PYG{n}{has\PYGZus{}ponycopter} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Then a command line utility \sphinxstylestrong{protoc} can be used to generate classes
in any of your perferred languages

\sphinxstylestrong{Services} (rpc’s) are defined in the same \sphinxstyleemphasis{.proto} files like this

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{service} \PYG{n}{Greeter} \PYG{p}{\PYGZob{}}
        \PYG{n}{rpc} \PYG{n}{Name} \PYG{p}{(}\PYG{n}{ParamType}\PYG{p}{)} \PYG{n}{returns} \PYG{p}{(}\PYG{n}{ReturnType}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

here \sphinxstylestrong{ParamType} is a \sphinxstylestrong{message} which will be the type for the
parameter being passed and \sphinxstylestrong{ReturnType} is similary a \sphinxstylestrong{message}
which will be returned by the RPC

\#TODO: DNS TTL prelab

\#TODO: break down go code from lab 1
\#TODO: :optional: Development of DNS
\#TODO: :optional: Microkernal approach to Host networking


\chapter{Diggind in to the gRPC example code}
\label{\detokenize{grpc/grpc:diggind-in-to-the-grpc-example-code}}\label{\detokenize{grpc/grpc::doc}}

\section{Installing gRPC}
\label{\detokenize{grpc/grpc:installing-grpc}}
see the \sphinxhref{https://grpc.io/docs/quickstart/go/}{quickstart} for more detail

First you need to install the gRPC module for go
\sphinxSetupCaptionForVerbatim{Install Go Module for gRPC}
\def\sphinxLiteralBlockLabel{\label{\detokenize{grpc/grpc:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{GO111MODULE}\PYG{o}{=}on \PYG{c+c1}{\PYGZsh{} this forces go to use Go modules instead of GOPATH}
\PYGZdl{} go get google.golang.org/grpc@v1.28.1
\end{sphinxVerbatim}

The \sphinxstylestrong{GO111MODULE} situation is a bit of mess, this article explains it well
\sphinxurl{https://dev.to/maelvls/why-is-go111module-everywhere-and-everything-about-go-modules-24k}

Then install the \sphinxhref{https://github.com/protocolbuffers/protobuf}{protoc} compiler
If you’re on Arch Linux there is a package for it
\sphinxSetupCaptionForVerbatim{Install protobuf from AUR}
\def\sphinxLiteralBlockLabel{\label{\detokenize{grpc/grpc:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo pacman \PYGZhy{}Syu protobuf
\end{sphinxVerbatim}


\subsection{Go Import System Sidebar}
\label{\detokenize{grpc/grpc:go-import-system-sidebar}}
\sphinxstylestrong{OK…} Coming from a python \& kotlin background go’s import system is
a mess to deal with and has already caused me too much greif.

when I try to run the example code given in the \sphinxhref{https://grpc.io/docs/quickstart/go/}{quickstart} I get this
\sphinxSetupCaptionForVerbatim{I really wish GOROOT was a Guardians of the Galaxy reference}
\def\sphinxLiteralBlockLabel{\label{\detokenize{grpc/grpc:id3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
greeter\PYGZus{}server/main.go:30:2: package examples/helloworld/helloworld is not in GOROOT \PYG{o}{(}/usr/lib/go/src/examples/helloworld/helloworld\PYG{o}{)}
\end{sphinxVerbatim}

Clearly I’ve been spoiled by pythons import system


\bigskip\hrule\bigskip

\begin{quote}\begin{description}
\item[{Everything needs to be in the \$GOPATH}] \leavevmode
I thought this was my problem but it didn’t fix the issue

\end{description}\end{quote}


\bigskip\hrule\bigskip

\begin{quote}\begin{description}
\item[{\sphinxstylestrong{SUCCESS}}] \leavevmode
In Go,  every program must be part of a package. I did initialize a package, but I
did so one directory above where I should have. After running

\end{description}\end{quote}
\sphinxSetupCaptionForVerbatim{It’s always something simple isn’t it, That’s 1/2 hour I won’t get back}
\def\sphinxLiteralBlockLabel{\label{\detokenize{grpc/grpc:id4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} go mod init
\end{sphinxVerbatim}

So for future, \sphinxstylestrong{not in the GOROOT} means I probably didn’t initalize the package


\chapter{Lab 2: A Simplified Distributed Map Reduce}
\label{\detokenize{labs/lab2:lab-2-a-simplified-distributed-map-reduce}}\label{\detokenize{labs/lab2::doc}}
In this lab we implemented a “distributed” map reduce
(relies on a shared file system but otherwise runs independently).
There is one “master” process handling the assignment of map and reduce jobs.

During the mapping phase the Worker
process reads in a text file and produces a
set of key value pairs using a map function provided by
a plug\sphinxhyphen{}in. The results from the map function are stored in an intermediary
file from which the master can make files for the reduce tasks.

Once all the mapping is complete the Master goes through
the files produced from the mapping phase
and produces a file for each reduce task that will be run.

Finally for each reduce job a Worker process groups
the values by their keys, producing
a \sphinxcode{\sphinxupquote{map{[}string{]}{[}{]}string}}. Then the reduce function
provided by the plug\sphinxhyphen{}in will be called  on each
slice of strings and it’s associated key.
The resulting value will be stored with it’s key in
an output file.

Combining the results from all the reduce tasks is handled
by the provided template code.

\begin{sphinxadmonition}{note}{Note:}
This was my first time working with go so I may have done some
silly things in my implementation. I’m sure i’ll come to see
the issues in the coming weeks.
\end{sphinxadmonition}


\section{Basic Approach}
\label{\detokenize{labs/lab2:basic-approach}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Worker processes invoke a RPC \sphinxcode{\sphinxupquote{RequestTask()}} to receive
a job assignment from the master

\item {} 
Once a Worker completes a job it invokes another RPC \sphinxcode{\sphinxupquote{ConfirmComplete()}}
to inform the Master that the job has been finished

\item {} 
Workers continue to ask for assignments with \sphinxcode{\sphinxupquote{RequestTask()}}
until a \sphinxcode{\sphinxupquote{Finished}} flag is set in the response indicating there are
no more jobs

\item {} 
When all map jobs are complete a set of reduce jobs will be created.
A mutex lock will be held while preparing the files and creating the reduce
jobs so any Workers requesting a task at that time will hang until that
mutex is unlocked (this eliminates the need for explicit waiting)

\item {} 
Once reduce jobs are finished we will return true in the \sphinxcode{\sphinxupquote{Done()}}
which is called by a goroutine in the Master process every second (provided in the template code)

\end{enumerate}


\section{Implementation}
\label{\detokenize{labs/lab2:implementation}}

\subsection{Type Definitions}
\label{\detokenize{labs/lab2:type-definitions}}
I created types for the following purposes:
\begin{quote}\begin{description}
\item[{WorkerTask}] \leavevmode
a struct containing information about a job for the worker
to use

\item[{CompleteConfirmation}] \leavevmode
Information returned from \sphinxcode{\sphinxupquote{ConfirmComplete()}}.
It’s used to tell the Worker thread to wait when
necessary

\item[{SortedKV}] \leavevmode
A KeyValue pair that has a reduce task number (Bin number)
associated to it. Used to separate the results from map jobs
into files for the reduce tasks

\item[{JobInfo}] \leavevmode
Information about a job for the Master process

\item[{Master}] \leavevmode
The struct for the Master process. Contains global state
and Mutexes.

\end{description}\end{quote}
\sphinxSetupCaptionForVerbatim{Definition from rpc.go}
\def\sphinxLiteralBlockLabel{\label{\detokenize{labs/lab2:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// KeyValue type provided in the template}
\PYG{k+kd}{type} \PYG{n+nx}{KeyValue} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{Key}   \PYG{k+kt}{string}
        \PYG{n+nx}{Value} \PYG{k+kt}{string}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Infromation for a Worker process about a Job}
\PYG{k+kd}{type} \PYG{n+nx}{WorkerTask} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{Filename}     \PYG{k+kt}{string}
        \PYG{n+nx}{Reduce}       \PYG{k+kt}{bool}
        \PYG{n+nx}{WorkerNumber} \PYG{k+kt}{int}
        \PYG{n+nx}{Job}          \PYG{k+kt}{int}
        \PYG{n+nx}{NReducers}    \PYG{k+kt}{int}
        \PYG{n+nx}{Finish}       \PYG{k+kt}{bool}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Confirmation provided to a worker after they}
\PYG{c+c1}{// report a job as finished}
\PYG{k+kd}{type} \PYG{n+nx}{CompleteConfirmation} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{Wait} \PYG{k+kt}{bool}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Used to designate which reduce task should handle}
\PYG{c+c1}{// this key value pair (Bin is the reduce task number which}
\PYG{c+c1}{// should process it, it\PYGZsq{}s computed using a hash function)}
\PYG{k+kd}{type} \PYG{n+nx}{SortedKV} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{KV}  \PYG{n+nx}{KeyValue}
        \PYG{n+nx}{Bin} \PYG{k+kt}{int}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Definitions from master.go}
\def\sphinxLiteralBlockLabel{\label{\detokenize{labs/lab2:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{type} \PYG{n+nx}{JobInfo} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// The Worker number that the task has been asssigned to}
        \PYG{n+nx}{Assigned} \PYG{k+kt}{int}
        \PYG{c+c1}{// Flag to indicate that the task is finished}
        \PYG{n+nx}{Complete} \PYG{k+kt}{bool}
        \PYG{c+c1}{// name of the file being mapped/reduced}
        \PYG{n+nx}{Filename} \PYG{k+kt}{string}
        \PYG{c+c1}{// flag indicating a Reduce job}
        \PYG{n+nx}{Reducing} \PYG{k+kt}{bool}
        \PYG{c+c1}{// Counter used to determine that the task has ran too long}
        \PYG{n+nx}{RunTime} \PYG{k+kt}{int}
\PYG{p}{\PYGZcb{}}

\PYG{k+kd}{type} \PYG{n+nx}{Master} \PYG{k+kd}{struct} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// The list of jobs}
        \PYG{n+nx}{Jobs}     \PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{JobInfo}
        \PYG{n+nx}{JobMutex} \PYG{n+nx}{sync}\PYG{p}{.}\PYG{n+nx}{Mutex}
        \PYG{c+c1}{// The reduce files}
        \PYG{n+nx}{ReduceBuckets} \PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n+nx}{os}\PYG{p}{.}\PYG{n+nx}{File}
        \PYG{c+c1}{// Mutex for the master}
        \PYG{n+nx}{ReduceMutex} \PYG{n+nx}{sync}\PYG{p}{.}\PYG{n+nx}{Mutex}
        \PYG{c+c1}{// Number of reduces}
        \PYG{n+nx}{nReducers} \PYG{k+kt}{int}
        \PYG{c+c1}{// Flag to indicate that we are in the reduce phase}
        \PYG{n+nx}{Reducing} \PYG{k+kt}{bool}
        \PYG{c+c1}{// counter used to assign ids to tasks}
        \PYG{n+nx}{taskcount} \PYG{k+kt}{int}
        \PYG{n+nx}{FlagMutex} \PYG{n+nx}{sync}\PYG{p}{.}\PYG{n+nx}{Mutex}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{The Worker Process}
\label{\detokenize{labs/lab2:the-worker-process}}
The code for the Worker consists mainly of 3 important functions
\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Reduce()@\spxentry{Reduce()}}\index{Reduce()@\spxentry{Reduce()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Reduce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Reduce}}}{\emph{reducef func(string}\sphinxoptional{}, \emph{string) string}}{}
handles processing a reduce job

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Map()@\spxentry{Map()}}\index{Map()@\spxentry{Map()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Map}}}{\emph{mapf func(string}, \emph{string) {[}{]}Keyvalue}}{}
process a map job

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Worker()@\spxentry{Worker()}}\index{Worker()@\spxentry{Worker()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Worker}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Worker}}}{\emph{mapf func(string}, \emph{string) {[}{]}KeyValue}, \emph{reducef func(string}\sphinxoptional{}, \emph{string) string}}{}
The main entry point for a
Worker process to invoked by the template code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mapf}} (\sphinxstyleliteralemphasis{\sphinxupquote{func}}) \textendash{} The map function from the plugin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reducef}} (\sphinxstyleliteralemphasis{\sphinxupquote{func}}) \textendash{} the reduce function from the plugin

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{The Worker Function}
\label{\detokenize{labs/lab2:the-worker-function}}
The {\hyperref[\detokenize{labs/lab2:Worker}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Worker()}}}}} function calls the \sphinxcode{\sphinxupquote{RequestTask()}}
RPC from the Master, invokes the appropriate handler
({\hyperref[\detokenize{labs/lab2:Map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Map()}}}}} for {\hyperref[\detokenize{labs/lab2:Reduce}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Reduce()}}}}}) and then informs the
Master of completion using the \sphinxcode{\sphinxupquote{ConfirmComplete()}}
RPC

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{n+nx}{Worker}\PYG{p}{(}\PYG{n+nx}{mapf} \PYG{k+kd}{func}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{,} \PYG{k+kt}{string}\PYG{p}{)} \PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{KeyValue}\PYG{p}{,}
        \PYG{n+nx}{reducef} \PYG{k+kd}{func}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{k+kt}{string}\PYG{p}{)} \PYG{k+kt}{string}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{for} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{args} \PYG{o}{:=} \PYG{n+nx}{WorkRequest}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{resp} \PYG{o}{:=} \PYG{n+nx}{WorkerTask}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}requesting a task from the Master\PYGZdq{}}\PYG{p}{)}
                \PYG{n+nx}{call}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Master.RequestTask\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n+nx}{args}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n+nx}{resp}\PYG{p}{)}

                \PYG{k}{if} \PYG{n+nx}{resp}\PYG{p}{.}\PYG{n+nx}{Finish} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}quitting worker\PYGZdq{}}\PYG{p}{)}
                        \PYG{k}{return}
                \PYG{p}{\PYGZcb{}}

                \PYG{k}{if} \PYG{n+nx}{resp}\PYG{p}{.}\PYG{n+nx}{Filename} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}\PYGZdq{}} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}sleeping due to empty filename\PYGZdq{}}\PYG{p}{)}
                        \PYG{n+nx}{time}\PYG{p}{.}\PYG{n+nx}{Sleep}\PYG{p}{(}\PYG{n+nx}{time}\PYG{p}{.}\PYG{n+nx}{Second}\PYG{p}{)}
                        \PYG{k}{continue}
                \PYG{p}{\PYGZcb{}}

                \PYG{k}{if} \PYG{n+nx}{resp}\PYG{p}{.}\PYG{n+nx}{Reduce} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{Reduce}\PYG{p}{(}\PYG{n+nx}{resp}\PYG{p}{,} \PYG{n+nx}{reducef}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{Map}\PYG{p}{(}\PYG{n+nx}{resp}\PYG{p}{,} \PYG{n+nx}{mapf}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}

                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Confirming completion to the master\PYGZdq{}}\PYG{p}{)}
                \PYG{n+nx}{confirm} \PYG{o}{:=} \PYG{n+nx}{CompleteConfirmation}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{call}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Master.ConfirmFinish\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n+nx}{resp}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n+nx}{confirm}\PYG{p}{)}

                \PYG{k}{if} \PYG{n+nx}{confirm}\PYG{p}{.}\PYG{n+nx}{Wait} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{time}\PYG{p}{.}\PYG{n+nx}{Sleep}\PYG{p}{(}\PYG{n+nx}{time}\PYG{p}{.}\PYG{n+nx}{Second}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{The Map Function}
\label{\detokenize{labs/lab2:the-map-function}}
The {\hyperref[\detokenize{labs/lab2:Map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Map()}}}}} function is responsible for running a map job
and producing an intermediate file

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{n+nx}{Map}\PYG{p}{(}\PYG{n+nx}{task} \PYG{n+nx}{WorkerTask}\PYG{p}{,} \PYG{n+nx}{mapf} \PYG{k+kd}{func}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{,} \PYG{k+kt}{string}\PYG{p}{)} \PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{KeyValue}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{filename} \PYG{o}{:=} \PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{Filename}
        \PYG{c+c1}{//log.Printf(\PYGZdq{}reading in the task content from \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, filename)}
        \PYG{n+nx}{content}\PYG{p}{,} \PYG{n+nx}{err} \PYG{o}{:=} \PYG{n+nx}{ioutil}\PYG{p}{.}\PYG{n+nx}{ReadFile}\PYG{p}{(}\PYG{n+nx}{filename}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//log.Printf(\PYGZdq{}creating a temporary file for \PYGZpc{}s\PYGZdq{}, filename)}
        \PYG{n+nx}{tempfilename} \PYG{o}{:=} \PYG{n+nx}{fmt}\PYG{p}{.}\PYG{n+nx}{Sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}temp\PYGZus{}map\PYGZus{}\PYGZpc{}s\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nx}{f}\PYG{p}{,} \PYG{n+nx}{err} \PYG{o}{:=} \PYG{n+nx}{ioutil}\PYG{p}{.}\PYG{n+nx}{TempFile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}.\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{tempfilename}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//log.Printf(\PYGZdq{}performing the map operation on \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, filename)}
        \PYG{c+c1}{// perform the map and put values in itermediate file}

        \PYG{n+nx}{results} \PYG{o}{:=} \PYG{n+nx}{mapf}\PYG{p}{(}\PYG{n+nx}{filename}\PYG{p}{,} \PYG{n+nb}{string}\PYG{p}{(}\PYG{n+nx}{content}\PYG{p}{)}\PYG{p}{)}
        \PYG{c+c1}{//log.Printf(\PYGZdq{}writing data into \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, tempfilename)}

        \PYG{n+nx}{encoder} \PYG{o}{:=} \PYG{n+nx}{json}\PYG{p}{.}\PYG{n+nx}{NewEncoder}\PYG{p}{(}\PYG{n+nx}{f}\PYG{p}{)}
        \PYG{k}{for} \PYG{n+nx}{\PYGZus{}}\PYG{p}{,} \PYG{n+nx}{kv} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{results} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{skv} \PYG{o}{:=} \PYG{n+nx}{SortedKV}\PYG{p}{\PYGZob{}}\PYG{n+nx}{KV}\PYG{p}{:} \PYG{n+nx}{kv}\PYG{p}{,} \PYG{n+nx}{Bin}\PYG{p}{:} \PYG{n+nx}{ihash}\PYG{p}{(}\PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Key}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{NReducers}\PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{encoder}\PYG{p}{.}\PYG{n+nx}{Encode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n+nx}{skv}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// rename the temp file once we know the job is done}
        \PYG{n+nx}{newname} \PYG{o}{:=} \PYG{n+nx}{fmt}\PYG{p}{.}\PYG{n+nx}{Sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}map\PYGZus{}\PYGZpc{}d\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{)}
        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}renaming \PYGZpc{}s to \PYGZpc{}s\PYGZbs{}n\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{tempfilename}\PYG{p}{,} \PYG{n+nx}{newname}\PYG{p}{)}
        \PYG{n+nx}{err} \PYG{p}{=} \PYG{n+nx}{os}\PYG{p}{.}\PYG{n+nx}{Rename}\PYG{p}{(}\PYG{n+nx}{f}\PYG{p}{.}\PYG{n+nx}{Name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nx}{newname}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{The Reduce Function}
\label{\detokenize{labs/lab2:the-reduce-function}}
The {\hyperref[\detokenize{labs/lab2:Reduce}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Reduce()}}}}} function handles the reduce jobs

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{n+nx}{Reduce}\PYG{p}{(}\PYG{n+nx}{task} \PYG{n+nx}{WorkerTask}\PYG{p}{,} \PYG{n+nx}{reducef} \PYG{k+kd}{func}\PYG{p}{(}\PYG{k+kt}{string}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{k+kt}{string}\PYG{p}{)} \PYG{k+kt}{string}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{bin}\PYG{p}{,} \PYG{n+nx}{err} \PYG{o}{:=} \PYG{n+nx}{os}\PYG{p}{.}\PYG{n+nx}{Open}\PYG{p}{(}\PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{Filename}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//log.Println(\PYGZdq{}reading JSON from \PYGZdq{}, task.Filename)}
        \PYG{n+nx}{decoder} \PYG{o}{:=} \PYG{n+nx}{json}\PYG{p}{.}\PYG{n+nx}{NewDecoder}\PYG{p}{(}\PYG{n+nx}{bin}\PYG{p}{)}
        \PYG{n+nx}{kvs} \PYG{o}{:=} \PYG{n+nb}{make}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{KeyValue}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{\PYGZob{}}
                \PYG{k+kd}{var} \PYG{n+nx}{kv} \PYG{n+nx}{KeyValue}
                \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{:=} \PYG{n+nx}{decoder}\PYG{p}{.}\PYG{n+nx}{Decode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n+nx}{kv}\PYG{p}{)}\PYG{p}{;} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                        \PYG{k}{break}
                \PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{kvs} \PYG{p}{=} \PYG{n+nb}{append}\PYG{p}{(}\PYG{n+nx}{kvs}\PYG{p}{,} \PYG{n+nx}{kv}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//log.Println(\PYGZdq{}grouping data by key for\PYGZdq{}, task.Filename)}
        \PYG{n+nx}{bykey} \PYG{o}{:=} \PYG{n+nb}{make}\PYG{p}{(}\PYG{k+kd}{map}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{k+kt}{string}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n+nx}{\PYGZus{}}\PYG{p}{,} \PYG{n+nx}{kv} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{kvs} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{bykey}\PYG{p}{[}\PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Key}\PYG{p}{]} \PYG{p}{=} \PYG{n+nb}{append}\PYG{p}{(}\PYG{n+nx}{bykey}\PYG{p}{[}\PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Key}\PYG{p}{]}\PYG{p}{,} \PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Value}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//log.Println(\PYGZdq{}running reduce on each key for \PYGZdq{}, task.Filename)}
        \PYG{n+nx}{reduceresults} \PYG{o}{:=} \PYG{n+nb}{make}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{KeyValue}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n+nx}{key}\PYG{p}{,} \PYG{n+nx}{vals} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{bykey} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{reduced} \PYG{o}{:=} \PYG{n+nx}{reducef}\PYG{p}{(}\PYG{n+nx}{key}\PYG{p}{,} \PYG{n+nx}{vals}\PYG{p}{)}
                \PYG{n+nx}{kv} \PYG{o}{:=} \PYG{n+nx}{KeyValue}\PYG{p}{\PYGZob{}}\PYG{n+nx}{Key}\PYG{p}{:} \PYG{n+nx}{key}\PYG{p}{,} \PYG{n+nx}{Value}\PYG{p}{:} \PYG{n+nx}{reduced}\PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{reduceresults} \PYG{p}{=} \PYG{n+nb}{append}\PYG{p}{(}\PYG{n+nx}{reduceresults}\PYG{p}{,} \PYG{n+nx}{kv}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{n+nx}{sort}\PYG{p}{.}\PYG{n+nx}{Sort}\PYG{p}{(}\PYG{n+nx}{ByKey}\PYG{p}{(}\PYG{n+nx}{reduceresults}\PYG{p}{)}\PYG{p}{)}

        \PYG{n+nx}{outputfile}\PYG{p}{,} \PYG{n+nx}{err} \PYG{o}{:=} \PYG{n+nx}{os}\PYG{p}{.}\PYG{n+nx}{Create}\PYG{p}{(}\PYG{n+nx}{fmt}\PYG{p}{.}\PYG{n+nx}{Sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}mr\PYGZhy{}out\PYGZhy{}\PYGZpc{}d\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{task}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{err} \PYG{o}{!=} \PYG{k+kc}{nil} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Fatal}\PYG{p}{(}\PYG{n+nx}{err}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//log.Println(\PYGZdq{}Writing redults to \PYGZdq{}, outputfile.Name())}
        \PYG{k}{for} \PYG{n+nx}{\PYGZus{}}\PYG{p}{,} \PYG{n+nx}{kv} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{reduceresults} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{outputfile}\PYG{p}{.}\PYG{n+nx}{WriteString}\PYG{p}{(}
                        \PYG{n+nx}{fmt}\PYG{p}{.}\PYG{n+nx}{Sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZpc{}v \PYGZpc{}v\PYGZbs{}n\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Key}\PYG{p}{,} \PYG{n+nx}{kv}\PYG{p}{.}\PYG{n+nx}{Value}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{The Master Process}
\label{\detokenize{labs/lab2:the-master-process}}
The important functions for the Master are:
\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Master.RequestTask()@\spxentry{Master.RequestTask()}}\index{Master.RequestTask()@\spxentry{Master.RequestTask()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Master.RequestTask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Master.}}\sphinxbfcode{\sphinxupquote{RequestTask}}}{\emph{args \textasciigrave{}*workreqest\textasciigrave{}}, \emph{reply \textasciigrave{}*WorkerTask\textasciigrave{}}}{}
Handles assignment of jobs

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Master.ConfirmFinish()@\spxentry{Master.ConfirmFinish()}}\index{Master.ConfirmFinish()@\spxentry{Master.ConfirmFinish()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Master.ConfirmFinish}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Master.}}\sphinxbfcode{\sphinxupquote{ConfirmFinish}}}{\emph{mapf func(}}{}
Handles completed jobs

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!Master.StartReducePhase()@\spxentry{Master.StartReducePhase()}}\index{Master.StartReducePhase()@\spxentry{Master.StartReducePhase()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{labs/lab2:Master.StartReducePhase}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Master.}}\sphinxbfcode{\sphinxupquote{StartReducePhase}}}{}{}
Creates reduce jobs from the intermediate map files

\end{fulllineitems}


\sphinxcode{\sphinxupquote{RequestTask()}} finds the next available task and supplies the
task information to the Worker
\sphinxSetupCaptionForVerbatim{RequestTask}
\def\sphinxLiteralBlockLabel{\label{\detokenize{labs/lab2:id3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{p}{(}\PYG{n+nx}{m} \PYG{o}{*}\PYG{n+nx}{Master}\PYG{p}{)} \PYG{n+nx}{RequestTask}\PYG{p}{(}\PYG{n+nx}{args} \PYG{o}{*}\PYG{n+nx}{WorkRequest}\PYG{p}{,} \PYG{n+nx}{reply} \PYG{o}{*}\PYG{n+nx}{WorkerTask}\PYG{p}{)} \PYG{k+kt}{error} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{JobMutex}\PYG{p}{.}\PYG{n+nx}{Lock}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{defer} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{JobMutex}\PYG{p}{.}\PYG{n+nx}{Unlock}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{FlagMutex}\PYG{p}{.}\PYG{n+nx}{Lock}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{defer} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{FlagMutex}\PYG{p}{.}\PYG{n+nx}{Unlock}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{for} \PYG{n+nx}{i} \PYG{o}{:=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{p}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{)}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{job} \PYG{o}{:=} \PYG{o}{\PYGZam{}}\PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}
                \PYG{k}{if} \PYG{n+nx}{job}\PYG{p}{.}\PYG{n+nx}{Assigned} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{Filename} \PYG{p}{=} \PYG{n+nx}{job}\PYG{p}{.}\PYG{n+nx}{Filename}
                        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{taskcount}\PYG{o}{++}
                        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}assigned job \PYGZpc{}d, \PYGZpc{}s to worker \PYGZpc{}d\PYGZbs{}n\PYGZdq{}}\PYG{p}{,}
                                \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{taskcount}\PYG{p}{,} \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{Filename}\PYG{p}{,} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{taskcount}\PYG{p}{)}
                        \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{WorkerNumber} \PYG{p}{=} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{taskcount}
                        \PYG{n+nx}{job}\PYG{p}{.}\PYG{n+nx}{Assigned} \PYG{p}{=} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{taskcount}
                        \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{NReducers} \PYG{p}{=} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{nReducers}
                        \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{Job} \PYG{p}{=} \PYG{n+nx}{i}
                        \PYG{k}{if} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Reducing} \PYG{p}{\PYGZob{}}
                                \PYG{n+nx}{reply}\PYG{p}{.}\PYG{n+nx}{Reduce} \PYG{p}{=} \PYG{k+kc}{true}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{return} \PYG{k+kc}{nil}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{ConfirmFinish()}} marks the job as done and initiates the
reduce phase once all the map jobs are finished
\sphinxSetupCaptionForVerbatim{ConfirmFinish}
\def\sphinxLiteralBlockLabel{\label{\detokenize{labs/lab2:id4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{p}{(}\PYG{n+nx}{m} \PYG{o}{*}\PYG{n+nx}{Master}\PYG{p}{)} \PYG{n+nx}{ConfirmFinish}\PYG{p}{(}\PYG{n+nx}{args} \PYG{o}{*}\PYG{n+nx}{WorkerTask}\PYG{p}{,} \PYG{n+nx}{reply} \PYG{o}{*}\PYG{n+nx}{CompleteConfirmation}\PYG{p}{)} \PYG{k+kt}{error} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{JobMutex}\PYG{p}{.}\PYG{n+nx}{Lock}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{defer} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{JobMutex}\PYG{p}{.}\PYG{n+nx}{Unlock}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{[}\PYG{n+nx}{args}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{Complete} \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n+nx}{errors}\PYG{p}{.}\PYG{n+nx}{New}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Job already finished\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{[}\PYG{n+nx}{args}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{Complete} \PYG{p}{=} \PYG{k+kc}{true}
        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Job: \PYGZpc{}d completed by \PYGZpc{}d\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{args}\PYG{p}{.}\PYG{n+nx}{Job}\PYG{p}{,} \PYG{n+nx}{args}\PYG{p}{.}\PYG{n+nx}{WorkerNumber}\PYG{p}{)}

        \PYG{n+nx}{done} \PYG{o}{:=} \PYG{k+kc}{true}
        \PYG{k}{for} \PYG{n+nx}{\PYGZus{}}\PYG{p}{,} \PYG{n+nx}{job} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{!}\PYG{n+nx}{job}\PYG{p}{.}\PYG{n+nx}{Complete} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{done} \PYG{p}{=} \PYG{k+kc}{false}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{n+nx}{done} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{p}{!}\PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Reducing} \PYG{p}{\PYGZob{}}
                \PYG{k}{for} \PYG{n+nx}{i} \PYG{o}{:=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{p}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{)}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{WriteToBuckets}\PYG{p}{(}\PYG{n+nx}{i}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{StartReducePhase}\PYG{p}{(}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{k+kc}{nil}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{StartReducePhase()}} creates the reduce jobs so their ready to be
assigned by \sphinxcode{\sphinxupquote{RequestTask()}}
\sphinxSetupCaptionForVerbatim{StartReducePhase}
\def\sphinxLiteralBlockLabel{\label{\detokenize{labs/lab2:id5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{func} \PYG{p}{(}\PYG{n+nx}{m} \PYG{o}{*}\PYG{n+nx}{Master}\PYG{p}{)} \PYG{n+nx}{StartReducePhase}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{FlagMutex}\PYG{p}{.}\PYG{n+nx}{Lock}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Reducing} \PYG{p}{=} \PYG{k+kc}{true}
        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{FlagMutex}\PYG{p}{.}\PYG{n+nx}{Unlock}\PYG{p}{(}\PYG{p}{)}

        \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Renaming temp files and creating reduce tasks\PYGZdq{}}\PYG{p}{)}

        \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs} \PYG{p}{=} \PYG{n+nb}{make}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{n+nx}{JobInfo}\PYG{p}{,} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{nReducers}\PYG{p}{)}
        \PYG{k}{for} \PYG{n+nx}{i}\PYG{p}{,} \PYG{n+nx}{f} \PYG{o}{:=} \PYG{k}{range} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{ReduceBuckets} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{newname} \PYG{o}{:=} \PYG{n+nx}{fmt}\PYG{p}{.}\PYG{n+nx}{Sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}mr\PYGZus{}\PYGZpc{}d\PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{i}\PYG{p}{)}
                \PYG{n+nx}{os}\PYG{p}{.}\PYG{n+nx}{Rename}\PYG{p}{(}\PYG{n+nx}{f}\PYG{p}{.}\PYG{n+nx}{Name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nx}{newname}\PYG{p}{)}
                \PYG{n+nx}{f}\PYG{p}{.}\PYG{n+nx}{Close}\PYG{p}{(}\PYG{p}{)}
                \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]} \PYG{p}{=} \PYG{n+nx}{JobInfo}\PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{Filename}\PYG{p}{:} \PYG{n+nx}{newname}\PYG{p}{,}
                        \PYG{n+nx}{Reducing}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
                \PYG{p}{\PYGZcb{}}
                \PYG{n+nx}{log}\PYG{p}{.}\PYG{n+nx}{Println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}added job \PYGZdq{}}\PYG{p}{,} \PYG{n+nx}{m}\PYG{p}{.}\PYG{n+nx}{Jobs}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The rest of the system is implemented in the provided template code


\section{Limitations}
\label{\detokenize{labs/lab2:limitations}}

\section{Dev Log}
\label{\detokenize{labs/lab2:dev-log}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Initialized Master with 2 Maps. One to keep track of which files are currently being mapped and
another to keep track of which files have been successfully mapped

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
Likley will need to use a Mutex for the Maps as Go maps are not threadsafe
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Created a rpc \sphinxcode{\sphinxupquote{RequestTask()}} which workers can call to receive a filename \& a boolean indicating
whether to act as a mapper or a reducer

\item {} 
Implemented the Mapping functionallity in the worker
\sphinxhyphen{} Logged Json serialization of each KeyValue returned from mapf in a TempFile
\sphinxhyphen{} Rename temp file once all KeyValues have been properly written

\end{enumerate}
\begin{quote}\begin{description}
\item[{End of Lab}] \leavevmode
Had some problems with the go import/build system which took up about 1/2 hour of the lab.
Otherwise I’m happy with the progress

\item[{Next Steps}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
When the code in invoked from the test script the temp files cannot be found properly.
using absolute paths will probably fix this
\begin{itemize}
\item {} 
FIXED: needed to remove “../” from the filename received from master

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
The shared map will probably cause race conditions. Atleast wrap the access in
a function so it’ll be easy to fix this later
\begin{itemize}
\item {} 
FIXED: Added a Mutex to the Master struct for this purpose

\end{itemize}

\item {} 
Create an RPC for workers to call when whey have finished.
This RPC can then handle determining if we are Done or not,
once mapping is done \sphinxcode{\sphinxupquote{RequestTask()}} can start handing outreduce tasks
\begin{itemize}
\item {} 
FIXED: Added an RPC for the worker to call when they finish

\item {} 
The Files map is updated so the main RPC will know when
to start handing out Reduce Tasks

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Create an id/numbering system for the workers, You will need this to make sure the same
file is not mapped twice (if a worker finishes after the timeout we will need to tell
the difference between it and the newly dispatched worker)
\begin{itemize}
\item {} 
DONE

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Create and start a GoRoutine to keep track of how long
workers have been running and free the filenames to be given
out again by \sphinxcode{\sphinxupquote{RequestTask()}} when the workers take to long (10s)
\begin{itemize}
\item {} 
DONE: Was able to use the Done() routine which is already called
every second

\end{itemize}

\item {} 
Assign Reduce tasks after the Map tasks have completed
\begin{itemize}
\item {} 
DONE: The list of input files is split evenly umong the
available workers and provided on the next request to
\sphinxcode{\sphinxupquote{RequestTask()}}

\end{itemize}

\end{enumerate}

\item[{TODO}] \leavevmode
Assign Reduce Tasks
\begin{itemize}
\item {} 
DONE:

\end{itemize}

\item[{TODO}] \leavevmode
Put loop in workers to continually request tasks
\begin{itemize}
\item {} 
DONE:

\end{itemize}

\item[{Bug}] \leavevmode
Test hangs after first 3 maps
\begin{itemize}
\item {} 
Nevermind, not a bug. The test only runs
3 workers

\end{itemize}

\item[{Bug}] \leavevmode
Tests pass with 2 workers but not with 3. Reduce buckets are being written to after
the reduce tasks have been started
\begin{itemize}
\item {} \begin{description}
\item[{FIXED: Tasks were being marked complete when the started processing}] \leavevmode
not after finishing

\end{description}

\end{itemize}

\item[{Issue}] \leavevmode
Producing the reduce files from each of the worker threads output files is
really slow

\item[{Note}] \leavevmode
I had to move the bin sorting to the end of the map phase before the reduce phase.
It seems the order that these are done is important but I don’t understand why. A Mutex
is used so there should not be any concurrency issues

\item[{Bug}] \leavevmode
Hangs on crash.go. It gets to the reduce tasks fine but eventually
tasks stop being handed out without the code finishing.
The Done function checks that all tasks are finished and then returns true,
so it should not be possible for the code to hang unless there are still some tasks
not marked as complete. Perhaps tasks are not being re\sphinxhyphen{}assigned properly
when a reducer fails mid shift
\begin{itemize}
\item {} 
FIXED: I was looping over the jobs using range. So when the assigned \& complete variables were
changed in the loop it was a copy that was changed and not the real value. By getting the
correct address of each job and using that the issue was fixed

\end{itemize}

\item[{DONE}] \leavevmode
All tests passing as of May 24th 2020. Also tested with up to 6 worker processes

\end{description}\end{quote}


\chapter{CSC 462 Lab \#3. Complexity Analysis of Map Reduce}
\label{\detokenize{labs/lab3report:csc-462-lab-3-complexity-analysis-of-map-reduce}}\label{\detokenize{labs/lab3report::doc}}

\section{Sequential Map Reduce, A Baseline}
\label{\detokenize{labs/lab3report:sequential-map-reduce-a-baseline}}
Before proceeding with testing my implementation from Lab 2
I will first gather some metrics from
the sequential implementation given in \sphinxtitleref{mrseqential.go}.
This baseline will be used to determine at what point the
multi\sphinxhyphen{}process implementation becomes worthwhile and what
the trade offs are in regards to space \& time complexity.


\section{The Phases of Map Reduce (In the Sequential Case)}
\label{\detokenize{labs/lab3report:the-phases-of-map-reduce-in-the-sequential-case}}
In order to estimate the performance of a sequential map\sphinxhyphen{}reduce
I will be collecting the following information at each step
in the execution.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Read input files and pass into the map function, producing
a collection of intermediate values.
\begin{itemize}
\item {} 
Time taken to read in the input files and produce
the intermediate collection.

\item {} 
Space required to store the intermediate values

\item {} 
Time taken to sort the intermediate values

\end{itemize}

\item {} 
Group the intermediate values by key, producing a list of
values for every key.
\begin{itemize}
\item {} 
Time taken to group the values by key

\item {} 
Amount of memory used in that process

\end{itemize}

\item {} 
Run Reduce on each key and create a single output file
\begin{itemize}
\item {} 
Time taken to complete all reduce jobs and produce
the full output

\end{itemize}

\end{enumerate}




\section{Modifications to \sphinxtitleref{mrsequential.go}}
\label{\detokenize{labs/lab3report:modifications-to-mrsequential-go}}


\renewcommand{\indexname}{Index}
\printindex
\end{document}